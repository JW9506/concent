import React, { Component, Fragment } from 'react';
import {
  MODULE_DEFAULT, CC_FRAGMENT_PREFIX, CURSOR_KEY, CCSYNC_KEY,
  MODULE_GLOBAL, STATE_FOR_ALL_CC_INSTANCES_OF_ONE_MODULE,
  EFFECT_AVAILABLE, EFFECT_STOPPED
} from '../support/constant';
import ccContext from '../cc-context';
import * as util from '../support/util';
import getFeatureStrAndStpMapping from '../core/base/get-feature-str-and-stpmapping';
import * as ev from '../core/event';
import * as ccRef from '../core/ref';
import * as base from '../core/base';
import extractStateByCcsync from '../core/state/extract-state-by-ccsync';
import watchKeyForRef from '../core/watch/watch-key-for-ref';
import getWatchSpec from '../core/watch/get-watch-spec';
import computeValueForRef from '../core/computed/compute-value-for-ref';
import getComputedSpec from '../core/computed/get-computed-spec';

const { ccClassKey_ccClassContext_, fragmentFeature_classKey_, computed, store: { getState, getPrevState }, moduleName_stateKeys_ } = ccContext;

let seq = 0;
//虽然CcFragment实例默认属于$$default模块，但是它的state是独立的，
function getStateModule() {
  seq++;
  return Symbol(`__for_cc_fragment_state_${seq}__`);
}

/**
 * 根据connect参数动态的把CcFragment划为某个ccClassKey的实例，同时计算出stateToPropMapping值
 * @param connectSpec 形如: {foo:'*', bar:['b1', 'b2']}
 */
function getFragmentClassKeyAndStpMapping(connectSpec) {
  if (!util.isObjectNotNull(connectSpec)) {//代表没有connect到store任何模块的CcFragment
    return { ccClassKey: `${CC_FRAGMENT_PREFIX}_0`, stateToPropMapping: null };
  }

  const { featureStr, stateToPropMapping } = getFeatureStrAndStpMapping(connectSpec);
  let ccClassKey = fragmentFeature_classKey_[featureStr];
  if (ccClassKey) {
    return { ccClassKey, stateToPropMapping };
  } else {
    const oldFragmentNameCount = ccContext.fragmentNameCount;
    const fragmentNameCount = oldFragmentNameCount + 1;
    ccContext.fragmentNameCount = fragmentNameCount;
    ccClassKey = `${CC_FRAGMENT_PREFIX}_${fragmentNameCount}`;
    fragmentFeature_classKey_[featureStr] = ccClassKey;
    return { ccClassKey, stateToPropMapping };
  }
}

const cursorKey = CURSOR_KEY;
const ccSyncKey = CCSYNC_KEY;

let idSeq = 0;
function getEId() {
  idSeq++;
  return Symbol(`__autoGen_${idSeq}__`);
}

export default class CcFragment extends Component {
  constructor(props, context) {
    super(props, context);

    let { ccKey, connect: connectSpec = {}, state = {} } = props;
    const { ccClassKey, stateToPropMapping } = getFragmentClassKeyAndStpMapping(connectSpec);

    let ccUniqueKey = '', isCcUniqueKeyAutoGenerated = false;
    if (ccKey) {// for CcFragment, if user supply ccKey to props, ccUniqueKey will equal ccKey
      ccUniqueKey = ccKey;
    } else {
      const { ccKey: ck, ccUniqueKey: cuk, isCcUniqueKeyAutoGenerated: ag } = base.computeCcUniqueKey(false, ccClassKey, ccKey, true);
      ccUniqueKey = cuk;
      isCcUniqueKeyAutoGenerated = ag;
      ccKey = ck;
    }
    const outProps = props.props || props;//把最外层的props传递给用户

    base.buildCcClassContext(ccClassKey, MODULE_DEFAULT, [], [], [], [], stateToPropMapping, true);
    ccRef.setRef(this, false, ccClassKey, ccKey, ccUniqueKey, {}, true);

    // for CcFragment, just put ccClassKey to module's cc class keys
    const { moduleName_ccClassKeys_ } = ccContext;
    const ccClassKeys = util.safeGetArrayFromObject(moduleName_ccClassKeys_, MODULE_DEFAULT);
    if (!ccClassKeys.includes(ccClassKey)) ccClassKeys.push(ccClassKey);

    const ctx = ccClassKey_ccClassContext_[ccClassKey];
    const connectedComputed = ctx.connectedComputed || {};
    const connectedState = ctx.connectedState || {};

    const reactForceUpdateRef = this.forceUpdate.bind(this);
    const reactSetStateRef = this.setState.bind(this);

    const refConnectedComputed = {};
    const refComputed = {};
    util.okeys(connectSpec).forEach(moduleName => {
      refConnectedComputed[moduleName] = {};
    });
    const ccState = {
      stateModule: getStateModule(), module: MODULE_DEFAULT, ccClassKey, ccKey, ccUniqueKey, isCcUniqueKeyAutoGenerated,
      stateToPropMapping, renderCount: 0, initTime: Date.now(), connect: connectSpec
    };

    this.cc = {
      // onUrlChanged: null,
      prevState: state,
      ccState,
      refConnectedComputed,
      refComputed,
      watch: null,
      watchSpec: null,
      computed: null,
      computedSpec: null,
      reactForceUpdate: (cb) => {
        ccState.renderCount += 1;
        //方便用户直接绑定forceUpdate
        if (typeof cb !== 'function') reactForceUpdateRef();
        else reactForceUpdateRef(cb);
      },
      reactSetState: (state, cb) => {
        ccState.renderCount += 1;
        reactSetStateRef(state, cb);
        // reactSetStateRef(state, () => {
        //   if (typeof cb !== 'function') reactForceUpdateRef();
        //   else reactForceUpdateRef(cb);
        // });
      }
    };

    // hook implement fo CcFragment
    const __hookMeta = {
      isCcFragmentMounted: false,
      useStateCount: 0,
      useStateCursor: 0,
      stateArr: [],
      useEffectCount: 0,
      useEffectCursor: 0,
      effectCbArr: [],
      effectSeeAoa: [],// shouldEffectExecute array of array
      effectSeeResult: [],// collect every effect fn's shouldExecute result
      effectCbReturnArr: [],
    };
    this.__hookMeta = __hookMeta;
    const hook = {
      useState: initialState => {
        let cursor = __hookMeta.useStateCursor;
        const stateArr = __hookMeta.stateArr;
        __hookMeta.useStateCursor++;
        if (__hookMeta.isCcFragmentMounted === false) {//render CcFragment before componentDidMount
          __hookMeta.useStateCount++;
          stateArr[cursor] = initialState;
        } else {
          cursor = cursor % __hookMeta.useStateCount;
        }

        const setter = e => {
          if (e.currentTarget && e.type) {
            __sync({ [cursorKey]: cursor }, e);
          } else {
            stateArr[cursor] = e;
            this.cc.reactForceUpdate();
          }
        }
        return [stateArr[cursor], setter];
      },
      useEffect: (cb, shouldEffectExecute) => {
        let cursor = __hookMeta.useEffectCursor;
        __hookMeta.useEffectCursor++;
        if (__hookMeta.isCcFragmentMounted === false) {
          __hookMeta.effectCbArr.push(cb);
          __hookMeta.effectSeeAoa.push(shouldEffectExecute);
          __hookMeta.useEffectCount++;
        } else {
          // if code running jump into this block, CcFragment already mounted, and now compute result for didUpdate
          cursor = cursor % __hookMeta.useEffectCount;
          if (Array.isArray(shouldEffectExecute)) {
            const len = shouldEffectExecute.length;
            if (len == 0) {
              __hookMeta.effectSeeResult[cursor] = false;// effect fn will been executed only in didMount
            } else {// compare prevSee and curSee
              let effectSeeResult = false;
              const prevSeeArr = __hookMeta.effectSeeAoa[cursor];
              if (!prevSeeArr) {
                effectSeeResult = true;
              } else {
                for (let i = 0; i < len; i++) {
                  if (shouldEffectExecute[i] !== prevSeeArr[i]) {
                    effectSeeResult = true;
                    break;
                  }
                }
              }
              __hookMeta.effectSeeAoa[cursor] = shouldEffectExecute;
              __hookMeta.effectSeeResult[cursor] = effectSeeResult;
              if (effectSeeResult) __hookMeta.effectCbArr[cursor] = cb;
            }
          } else {
            __hookMeta.effectSeeResult[cursor] = true;// effect fn will always been executed in didMount and didUpdate
            __hookMeta.effectSeeAoa[cursor] = shouldEffectExecute;
            __hookMeta.effectCbArr[cursor] = cb;
          }
        }
      }
    };

    const dispatcher = ccRef.getDispatcherRef();
    this.state = state;

    const __sync = (spec, e) => {
      if (spec[cursorKey] !== undefined) {//来自hook生成的setter调用
        const _cursor = spec[cursorKey];
        __hookMeta.stateArr[_cursor] = e.currentTarget.value;
        this.cc.reactForceUpdate();
        return;
      }

      const mockE = base.buildMockEvent(spec, e, STATE_FOR_ALL_CC_INSTANCES_OF_ONE_MODULE);
      if (!mockE) return;//参数无效

      const currentTarget = mockE.currentTarget;
      const dataset = currentTarget.dataset;

      if (e && e.stopPropagation) e.stopPropagation();
      if (dataset.ccsync.includes('/')) {// syncModuleState 同步模块的state状态
        dispatcher.$$sync(mockE);
      } else {// syncLocalState 同步本地的state状态
        const { state } = extractStateByCcsync(dataset.ccsync, currentTarget.value, dataset.ccint, this.state, mockE.isToggleBool);
        __fragmentParams.setState(state);
      }
    };

    const effectItems = [];// {fn:function, status:0, eId:'', immediate:true}
    const effectReturnCbs = [];// {fn:function, status:0, eId:'', immediate:true}
    this.__staticEffectMeta = {
      effectItems,
      effectReturnCbs,
    };

    let isWatchDefined = false;
    let isComputedDefined = false;
    const __fragmentParams = {
      isCcFragment:true,
      refComputed,
      refConnectedComputed,
      connectedComputed,
      connectedState,
      // 新增defineEffect相关的支持
      defineEffect: (fn, stateKeys, eId, immediate = true) => {
        if (typeof fn !== 'function') throw new Error('type of defineEffect first param must be function');
        if (stateKeys !== null && stateKeys !== undefined) {
          if (!Array.isArray(stateKeys)) throw new Error('type of defineEffect second param must be one of them(array, null, undefined)');
        }

        const _fn = fn.bind(this, this.__fragmentParams, outProps);
        const _eId = eId || getEId();
        const effectItem = { fn: _fn, stateKeys, status: EFFECT_AVAILABLE, eId: _eId, immediate };
        effectItems.push(effectItem);
      },
      stopEffect: (eId) => {
        const target = effectItems.find(v => v.eId === eId);
        if (target) target.status = EFFECT_STOPPED;
      },
      resumeEffect: (eId) => {
        const target = effectItems.find(v => v.eId === eId);
        if (target) target.status = EFFECT_AVAILABLE;
      },
      removeEffect: (eId) => {
        const targetIdx = effectItems.findIndex(v => v.eId === eId);
        if (targetIdx >= 0) effectItems.splice(targetIdx, 1);
      },
      stopAllEffect: () => {
        effectItems.forEach(v => v.status = EFFECT_STOPPED);
      },
      resumeAllEffect: () => {
        effectItems.forEach(v => v.status = EFFECT_AVAILABLE);
      },
      removeAllEffect: () => {
        effectItems.length = 0;
      },
      defineWatch: (watch) => {
        if (isWatchDefined) throw new Error('defineWatch can only been one time');
        const watchSpec = getWatchSpec(watch, this.__fragmentParams);
        this.cc.watch = watch;
        this.cc.watchSpec = watchSpec;
      },
      defineComputed: (computed) => {
        if (isComputedDefined) throw new Error('defineComputed can only been one time');
        const computedSpec = getComputedSpec(computed, this.__fragmentParams);
        this.cc.computed = computed;
        this.cc.computedSpec = computedSpec;
      },
      method: {},
      // ------ end ------

      toggleBool: (e, delay = -1, idt = '') => {
        if (typeof e === 'string') return __sync.bind(null, { [ccSyncKey]: e, type: 'bool', delay, idt });
        __sync({ type: 'bool' }, e);
      },
      //if <Input onChange={(value:string, value2:string)=>void} />
      // <Input onChange={this.sync} /> not work!!!
      // <Input onChange={this.sync('foo/f1')} /> ok
      // only <input data-ccsync="foo/f1" onChange={this.sync} /> ok
      // only <input onChange={this.sync('foo/f1')} /> ok
      sync: (e, val, delay = -1, idt = '') => {
        if (typeof e === 'string') return __sync.bind(null, { [ccSyncKey]: e, type: 'val', val, delay, idt });
        __sync({ type: 'val' }, e);//allow <input data-ccsync="foo/f1" onChange={this.sync} />
      },
      set: (ccsync, val, delay, idt) => {
        __sync({ [ccSyncKey]: ccsync, type: 'val', val, delay, idt });
      },
      // <Input onChange={this.syncInt} /> not work!!!
      // <Input onChange={this.syncInt('foo/bar')} /> ok
      // <input onChange={this.syncInt('foo/bar')} /> ok
      // <input data-ccsync="foo/f1" onChange={this.syncInt('foo/fq')} /> ok
      syncInt: (e, delay = -1, idt = '') => {
        if (typeof e === 'string') return __sync.bind(null, { [ccSyncKey]: e, type: 'int', delay, idt });
        __sync({ type: 'int' }, e);//<input data-ccsync="foo/f1" onChange={this.syncInt} />
      },
      onUrlChanged: (cb) => {
        this.cc.onUrlChanged = cb.bind(this);
      },
      hook,
      emit: (event, ...args) => {
        ev.findEventHandlersToPerform(event, { identity: null }, ...args);
      },
      emitIdentity: (event, identity, ...args) => {
        ev.findEventHandlersToPerform(event, { identity }, ...args);
      },
      on: (event, handler) => {
        ev.bindEventHandlerToCcContext(MODULE_DEFAULT, ccClassKey, ccUniqueKey, event, null, handler);
      },
      onIdentity: (event, identity, handler) => {
        ev.bindEventHandlerToCcContext(MODULE_DEFAULT, ccClassKey, ccUniqueKey, event, identity, handler);
      },
      dispatch: dispatcher.__$$getDispatchHandler(false, ccKey, ccUniqueKey, ccClassKey, STATE_FOR_ALL_CC_INSTANCES_OF_ONE_MODULE, MODULE_DEFAULT, null, null, null, -1),
      callDispatch: (...args) => {
        return this.__fragmentParams.dispatch.bind(this, ...args);
      },
      effect: dispatcher.__$$getEffectHandler(ccKey),
      xeffect: dispatcher.__$$getXEffectHandler(ccKey),
      setModuleState: (module, state, delay, identity) => {
        dispatcher.$$changeState(state, {
          ccKey, module, stateFor: STATE_FOR_ALL_CC_INSTANCES_OF_ONE_MODULE,
          broadcastTriggeredBy: null, delay, identity
        });
      },
      setGlobalState: (state, delay, identity) => {
        dispatcher.$$changeState(state, {
          ccKey, MODULE_GLOBAL, stateFor: STATE_FOR_ALL_CC_INSTANCES_OF_ONE_MODULE,
          broadcastTriggeredBy: null, delay, identity
        });
      },
      state,
      props,
      outProps,
      setState: (state, cb) => {
        const thisCc = this.cc;
        const thisState = this.state;
        const { stateModule, connect } = thisCc.ccState;
        computeValueForRef(stateModule, thisCc.computedSpec, thisCc.refComputed, thisCc.refConnectedComputed, thisState, state, __fragmentParams, true);
        const shouldCurrentRefUpdate = watchKeyForRef(stateModule, thisCc.watchSpec, connect, thisState, state);
        if (shouldCurrentRefUpdate) this.cc.reactSetState(state, cb);
      },
      forceUpdate: (cb) => {
        this.__fragmentParams.setState(this.state, cb);
      },
    };
    this.__fragmentParams = __fragmentParams;
  }

  componentWillMount() {
    const { setup } = this.props;
    if (setup) {
      const ctx = this.__fragmentParams;
      if (typeof setup !== 'function') throw new Error('type of setup must be function');
      const methodObj = setup(this.__fragmentParams);
      if (!util.isPlainJsonObject(methodObj)) throw new Error('type of setup return result must be an plain json object');
      util.okeys(methodObj).forEach(name => {
        const method = methodObj[name];
        if (typeof method === 'function') methodObj[name] = method.bind(this, ctx);
      });
      ctx.method = methodObj;
    }

    const thisCc = this.cc;
    const thisState = this.state;
    const { stateModule, connect } = thisCc.ccState;
    const computedSpec = thisCc.computedSpec, refComputed = thisCc.refComputed, refConnectedComputed = thisCc.refConnectedComputed;
    computeValueForRef(stateModule, computedSpec, refComputed, refConnectedComputed, thisState, thisState, this.__fragmentParams);
    util.okeys(connect).forEach(m=>{
      const mState = getState(m);
      computeValueForRef(m, computedSpec, refComputed, refConnectedComputed, mState, mState);
    });
  }
  executeHookEffect(callByDidMount) {
    const { effectCbArr, effectCbReturnArr } = this.__hookMeta;
    if (callByDidMount) {
      this.__hookMeta.isCcFragmentMounted = true;
      effectCbArr.forEach(cb => {
        const cbReturn = cb();
        if (typeof cbReturn === 'function') {
          effectCbReturnArr.push(cbReturn);
        } else {
          effectCbReturnArr.push(null);
        }
      });
    } else {
      const { effectSeeResult } = this.__hookMeta;
      effectCbArr.forEach((cb, idx) => {
        const shouldEffectExecute = effectSeeResult[idx];
        if (shouldEffectExecute) {
          const cbReturn = cb();
          if (typeof cbReturn === 'function') {
            effectCbReturnArr[idx] = cbReturn;
          }
        }
      });
    }
  }
  executeSetupEffect(callByDidMount) {
    const effectItems = this.__staticEffectMeta.effectItems;
    
    if (callByDidMount) {
      effectItems.forEach(item => {
        if (item.immediate === false) return;
        item.fn();
      });
    } else {//callByDidUpdate
      const prevState = this.cc.prevState;
      const curState = this.state;
      effectItems.forEach(item => {
        const { status, stateKeys, fn } = item;
        if (status === EFFECT_STOPPED) return;
        if (stateKeys) {
          const keysLen = stateKeys.length;
          if (keysLen === 0) return;
          let shouldEffectExecute = false;
          for (let i = 0; i < keysLen; i++) {
            const key = stateKeys[i];
            let targetCurState , targetPrevState, targetKey;
            if (key.includes('/')) {
              const [module, unmoduledKey] = key.split('/');
              const prevState = getPrevState(module);
              if (!prevState) {
                util.justWarning(`key[${key}] is invalid, its module[${module}] has not been declared in store!`);
                continue;
              }
              if (!moduleName_stateKeys_[module].includes(unmoduledKey)) {
                util.justWarning(`key[${key}] is invalid, its unmoduledKey[${unmoduledKey}] has not been declared in state!`);
                continue;
              }
              targetCurState = getState(module);
              targetPrevState = prevState;
              targetKey = unmoduledKey;
            } else {
              targetCurState = curState;
              targetPrevState = prevState;
              targetKey = key;
            }

            if (targetPrevState[targetKey] !== targetCurState[targetKey]) {
              shouldEffectExecute = true;
              break;
            }
          }
          if (shouldEffectExecute) {
            fn()
          }
        } else {
          fn();
        }
      });
    }
  }
  componentDidMount() {
    this.executeSetupEffect(true);
    this.executeHookEffect(true);
  }
  shouldComponentUpdate(_, nextState) {
    const curState = this.state;
    this.cc.prevState = curState;
    return curState !== nextState;
  }
  componentDidUpdate() {
    this.executeSetupEffect();
    this.executeHookEffect();
    this.cc.prevState = this.state;//!!!  重置prevState，防止其他模块的更新操作再次执行executeSetupEffect时，判断shouldEffectExecute失效
  }
  componentWillUnmount() {
    this.__hookMeta.effectCbReturnArr.forEach(cb => {
      if (cb) cb();
    });

    const { ccUniqueKey, ccClassKey } = this.cc.ccState;
    ev.offEventHandlersByCcUniqueKey(ccUniqueKey);
    ccRef.unsetRef(ccClassKey, ccUniqueKey);
    if (super.componentWillUnmount) super.componentWillUnmount();
  }
  render() {
    const { children, render } = this.props
    const view = render || children;
    if (typeof view === 'function') {
      this.__fragmentParams.state = this.state;//注意这里，一定要每次都取最新的
      return view(this.__fragmentParams) || React.createElement(Fragment);
    } else {
      if (React.isValidElement(view)) {
        util.justWarning(`you are trying to specify a react dom to be CcFragment's children, it will never been rendered again no matter how your state changed!!!`);
      }
      return view;
    }
  }

}
