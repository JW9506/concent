import {
  MODULE_DEFAULT,
} from '../../support/constant';
import ccContext from '../../cc-context';
import * as util from '../../support/util';
import * as ccRef from '../ref';
import computeCcUniqueKey from './compute-cc-unique-key';
import buildCcClassContext from './build-cc-class-context';
import getFragmentClassKeyAndStpMapping from './get-fragment-classkey-and-stpmapping';


export default function (ref, props, fragmentPrefix) {
  let { ccKey, connect: connectSpec = {}, state = {}, module, storedKeys, watchedKeys = '*', tag } = props;
  //计算fragment所属的模块
  const fragmentModule = module || MODULE_DEFAULT;
  const mergedState = Object.assign(state, getState(fragmentModule));
  ref.state = mergedState;

  let _storedKeys = [];
  if (storedKeys !== undefined) {
    if (!ccKey) throw new Error('you must supply ccKey explicitly to props if you specify storedKeys');
    _storedKeys = storedKeys;
  }

  let _watchedKeys = watchedKeys;
  if (watchedKeys === '*') {
    _watchedKeys = moduleName_stateKeys_[fragmentModule];
  }

  const { ccClassKey, stateToPropMapping, connectedModuleNames } = getFragmentClassKeyAndStpMapping(connectSpec, fragmentModule, fragmentPrefix, watchedKeys);

  let ccUniqueKey = '', isCcUniqueKeyAutoGenerated = false;
  if (ccKey) {// for CcFragment, if user supply ccKey to props, ccUniqueKey will equal ccKey
    ccUniqueKey = ccKey;
  } else {
    const { ccKey: ck, ccUniqueKey: cuk, isCcUniqueKeyAutoGenerated: ag } = computeCcUniqueKey(false, ccClassKey, ccKey, true, tag);
    ccUniqueKey = cuk;
    isCcUniqueKeyAutoGenerated = ag;
    ccKey = ck;
  }

  buildCcClassContext(ccClassKey, fragmentModule, watchedKeys, _watchedKeys, stateToPropMapping, connectedModuleNames, true);
  ccRef.setRef(ref, false, ccClassKey, ccKey, ccUniqueKey, {}, true);

  // for CcFragment, just put ccClassKey to module's cc class keys
  const { moduleName_ccClassKeys_ } = ccContext;
  const ccClassKeys = util.safeGetArrayFromObject(moduleName_ccClassKeys_, fragmentModule);
  if (!ccClassKeys.includes(ccClassKey)) ccClassKeys.push(ccClassKey);

  const refConnectedComputed = {};
  okeys(connectSpec).forEach(moduleName => {
    refConnectedComputed[moduleName] = {};
  });
  const ccState = {
    storedKeys: _storedKeys, watchedKeys: _watchedKeys,
    module: fragmentModule, ccClassKey, ccKey, ccUniqueKey, isCcUniqueKeyAutoGenerated,
    stateToPropMapping, renderCount: 0, initTime: Date.now(), connect: connectSpec
  };

  const cc = {
    ccKey,
    ccUniqueKey,
    ccClassKey,

    // onUrlChanged: null,
    ccState,
    refConnectedComputed,
    refComputed: {},
    watch: null,
    watchSpec: null,
    computed: null,
    computedSpec: null,
    reactForceUpdate: (cb) => {
      ccState.renderCount += 1;
      //方便用户直接绑定forceUpdate
      if (typeof cb !== 'function') ref.forceUpdate();
      else ref.forceUpdate(cb);
    },
    reactSetState: (state, cb) => {
      ccState.renderCount += 1;
      ref.setState(state, cb);
    }
  };

  if (Object.defineProperty) {
    Object.defineProperty(this, 'cc', {
      enumerable: false,
      writable: false,
      configurable: false,
      value: cc
    });
  } else {
    ref.cc = cc;
  }

}