import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import React, { Component, Fragment } from 'react';
import { MODULE_DEFAULT, CC_FRAGMENT_PREFIX, MODULE_GLOBAL, STATE_FOR_ALL_CC_INSTANCES_OF_ONE_MODULE } from '../support/constant';
import ccContext from '../cc-context';
import util from '../support/util';
import getFeatureStrAndStpMapping from '../core/base/get-feature-str-and-stpmapping';
import * as ev from '../core/event';
import * as ccRef from '../core/ref';
import * as base from '../core/base';
import extractStateByCcsync from '../core/state/extract-state-by-ccsync';
var ccClassKey_ccClassContext_ = ccContext.ccClassKey_ccClassContext_,
    fragmentFeature_classKey_ = ccContext.fragmentFeature_classKey_,
    computed = ccContext.computed;
/**
 * 根据connect参数动态的把CcFragment划为某个ccClassKey的实例，同时计算出stateToPropMapping值
 * @param connectSpec 形如: {foo:'*', bar:['b1', 'b2']}
 */

function getFragmentClassKeyAndStpMapping(connectSpec) {
  if (!util.isObjectNotNull(connectSpec)) {
    //代表没有connect到store任何模块的CcFragment
    return {
      ccClassKey: CC_FRAGMENT_PREFIX + "_0",
      stateToPropMapping: null
    };
  }

  var _getFeatureStrAndStpM = getFeatureStrAndStpMapping(connectSpec),
      featureStr = _getFeatureStrAndStpM.featureStr,
      stateToPropMapping = _getFeatureStrAndStpM.stateToPropMapping;

  var ccClassKey = fragmentFeature_classKey_[featureStr];

  if (ccClassKey) {
    return {
      ccClassKey: ccClassKey,
      stateToPropMapping: stateToPropMapping
    };
  } else {
    var oldFragmentNameCount = ccContext.fragmentNameCount;
    var fragmentNameCount = oldFragmentNameCount + 1;
    ccContext.fragmentNameCount = fragmentNameCount;
    ccClassKey = CC_FRAGMENT_PREFIX + "_" + fragmentNameCount;
    fragmentFeature_classKey_[featureStr] = ccClassKey;
    return {
      ccClassKey: ccClassKey,
      stateToPropMapping: stateToPropMapping
    };
  }
}

var CcFragment =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(CcFragment, _Component);

  function CcFragment(props, context) {
    var _this;

    _this = _Component.call(this, props, context) || this;
    var ccKey = props.ccKey,
        _props$connect = props.connect,
        connectSpec = _props$connect === void 0 ? {} : _props$connect,
        _props$state = props.state,
        state = _props$state === void 0 ? {} : _props$state;

    var _getFragmentClassKeyA = getFragmentClassKeyAndStpMapping(connectSpec),
        ccClassKey = _getFragmentClassKeyA.ccClassKey,
        stateToPropMapping = _getFragmentClassKeyA.stateToPropMapping;

    var ccUniqueKey = '',
        isCcUniqueKeyAutoGenerated = false;

    if (ccKey) {
      // for CcFragment, if user supply ccKey to props, ccUniqueKey will equal ccKey
      ccUniqueKey = ccKey;
    } else {
      var _base$computeCcUnique = base.computeCcUniqueKey(false, ccClassKey, ccKey, true),
          ck = _base$computeCcUnique.ccKey,
          cuk = _base$computeCcUnique.ccUniqueKey,
          ag = _base$computeCcUnique.isCcUniqueKeyAutoGenerated;

      ccUniqueKey = cuk;
      isCcUniqueKeyAutoGenerated = ag;
      ccKey = ck;
    }

    base.buildCcClassContext(ccClassKey, MODULE_DEFAULT, [], [], [], [], stateToPropMapping, true);
    ccRef.setRef(_assertThisInitialized(_this), false, ccClassKey, ccKey, ccUniqueKey, {}, true); // for CcFragment, just put ccClassKey to module's cc class keys

    var moduleName_ccClassKeys_ = ccContext.moduleName_ccClassKeys_;
    var ccClassKeys = util.safeGetArrayFromObject(moduleName_ccClassKeys_, MODULE_DEFAULT);
    if (!ccClassKeys.includes(ccClassKey)) ccClassKeys.push(ccClassKey);
    _this.$$connectedState = ccClassKey_ccClassContext_[ccClassKey].connectedState || {}; // only bind reactForceUpdateRef for CcFragment

    var reactForceUpdateRef = _this.forceUpdate.bind(_assertThisInitialized(_this));

    var ccState = {
      module: MODULE_DEFAULT,
      ccClassKey: ccClassKey,
      ccKey: ccKey,
      ccUniqueKey: ccUniqueKey,
      isCcUniqueKeyAutoGenerated: isCcUniqueKeyAutoGenerated,
      stateToPropMapping: stateToPropMapping,
      renderCount: 0
    };
    _this.cc = {
      ccState: ccState,
      reactForceUpdate: function reactForceUpdate(state, cb) {
        ccState.renderCount += 1;
        reactForceUpdateRef(state, cb);
      }
    }; // hook implement fo CcFragment

    var __hookMeta = {
      isCcFragmentMounted: false,
      useStateCount: 0,
      useStateCursor: 0,
      stateArr: [],
      useEffectCount: 0,
      useEffectCursor: 0,
      effectCbArr: [],
      effectSeeAoa: [],
      // shouldEffectExecute array of array
      effectSeeResult: [],
      // collect every effect fn's shouldExecute result
      effectCbReturnArr: []
    };
    _this.__hookMeta = __hookMeta;
    var hook = {
      useState: function useState(initialState) {
        var cursor = __hookMeta.useStateCursor;
        var stateArr = __hookMeta.stateArr;
        __hookMeta.useStateCursor++;

        if (__hookMeta.isCcFragmentMounted === false) {
          //render CcFragment before componentDidMount
          __hookMeta.useStateCount++;
          stateArr[cursor] = initialState;
        } else {
          cursor = cursor % __hookMeta.useStateCount;
        }

        var setter = function setter(e) {
          if (e.currentTarget && e.type) {
            _this.__fragmentParams.sync(e, cursor);
          } else {
            stateArr[cursor] = e;

            _this.cc.reactForceUpdate();
          }
        };

        return [stateArr[cursor], setter];
      },
      useEffect: function useEffect(cb, shouldEffectExecute) {
        var cursor = __hookMeta.useEffectCursor;
        __hookMeta.useEffectCursor++;

        if (__hookMeta.isCcFragmentMounted === false) {
          __hookMeta.effectCbArr.push(cb);

          __hookMeta.effectSeeAoa.push(shouldEffectExecute);

          __hookMeta.useEffectCount++;
        } else {
          // if code running jump into this block, CcFragment already mounted, and now compute result for didUpdate
          cursor = cursor % __hookMeta.useEffectCount;

          if (Array.isArray(shouldEffectExecute)) {
            var len = shouldEffectExecute.length;

            if (len == 0) {
              __hookMeta.effectSeeResult[cursor] = false; // effect fn will been executed only in didMount
            } else {
              // compare prevSee and curSee
              var effectSeeResult = false;
              var prevSeeArr = __hookMeta.effectSeeAoa[cursor];

              if (!prevSeeArr) {
                effectSeeResult = true;
              } else {
                for (var i = 0; i < len; i++) {
                  if (shouldEffectExecute[i] !== prevSeeArr[i]) {
                    effectSeeResult = true;
                    break;
                  }
                }
              }

              __hookMeta.effectSeeAoa[cursor] = shouldEffectExecute;
              __hookMeta.effectSeeResult[cursor] = effectSeeResult;
              if (effectSeeResult) __hookMeta.effectCbArr[cursor] = cb;
            }
          } else {
            __hookMeta.effectSeeResult[cursor] = true; // effect fn will always been executed in didMount and didUpdate

            __hookMeta.effectSeeAoa[cursor] = shouldEffectExecute;
            __hookMeta.effectCbArr[cursor] = cb;
          }
        }
      }
    };
    var dispatcher = ccRef.getDispatcherRef();
    _this.state = state;
    var __fragmentParams = {
      connectedComputed: computed._computedValue,
      hook: hook,
      connectedState: _this.$$connectedState,
      emit: function emit(event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        ev.findEventHandlersToPerform.apply(ev, [event, {
          identity: null
        }].concat(args));
      },
      emitIdentity: function emitIdentity(event, identity) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
          args[_key2 - 2] = arguments[_key2];
        }

        ev.findEventHandlersToPerform.apply(ev, [event, {
          identity: identity
        }].concat(args));
      },
      on: function on(event, handler) {
        ev.bindEventHandlerToCcContext(MODULE_DEFAULT, ccClassKey, ccUniqueKey, event, null, handler);
      },
      onIdentity: function onIdentity(event, identity, handler) {
        ev.bindEventHandlerToCcContext(MODULE_DEFAULT, ccClassKey, ccUniqueKey, event, identity, handler);
      },
      dispatch: dispatcher.__$$getDispatchHandler(STATE_FOR_ALL_CC_INSTANCES_OF_ONE_MODULE, MODULE_DEFAULT, null, null, null, -1, ccKey),
      effect: dispatcher.__$$getEffectHandler(ccKey),
      xeffect: dispatcher.__$$getXEffectHandler(ccKey),
      sync: function sync(e, cursor) {
        var currentTarget = e.currentTarget;
        var value = currentTarget.value,
            dataset = currentTarget.dataset;

        if (cursor != undefined) {
          // syncLocalHookState 同步本地的hook状态
          __hookMeta.stateArr[cursor] = value;

          _this.cc.reactForceUpdate();
        } else {
          var ccint = dataset.ccint,
              ccsync = dataset.ccsync;

          if (!ccsync) {
            return util.justWarning("data-ccsync attr no found, you must define it while using syncLocal");
          }

          if (ccsync.includes('/')) {
            // syncModuleState 同步模块的state状态
            dispatcher.$$sync(e, STATE_FOR_ALL_CC_INSTANCES_OF_ONE_MODULE);
          } else {
            // syncLocalState 同步本地的state状态
            var _extractStateByCcsync = extractStateByCcsync(ccsync, value, ccint, _this.state),
                _state = _extractStateByCcsync.state;

            __fragmentParams.setState(_state);
          }
        }
      },
      setModuleState: function setModuleState(module, state, lazyMs) {
        dispatcher.$$changeState(state, {
          ccKey: ccKey,
          module: module,
          stateFor: STATE_FOR_ALL_CC_INSTANCES_OF_ONE_MODULE,
          broadcastTriggeredBy: null,
          lazyMs: lazyMs
        });
      },
      setGlobalState: function setGlobalState(state, lazyMs) {
        dispatcher.$$changeState(state, {
          ccKey: ccKey,
          MODULE_GLOBAL: MODULE_GLOBAL,
          stateFor: STATE_FOR_ALL_CC_INSTANCES_OF_ONE_MODULE,
          broadcastTriggeredBy: null,
          lazyMs: lazyMs
        });
      },
      state: _this.state,
      setState: function setState(state) {
        _this.setState(state, function () {
          return _this.cc.reactForceUpdate();
        });
      }
    };
    _this.__fragmentParams = __fragmentParams;
    return _this;
  }

  var _proto = CcFragment.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var _this$__hookMeta = this.__hookMeta,
        effectCbArr = _this$__hookMeta.effectCbArr,
        effectCbReturnArr = _this$__hookMeta.effectCbReturnArr;
    this.__hookMeta.isCcFragmentMounted = true;
    effectCbArr.forEach(function (cb) {
      var cbReturn = cb();

      if (typeof cbReturn === 'function') {
        effectCbReturnArr.push(cbReturn);
      } else {
        effectCbReturnArr.push(null);
      }
    });
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    var _this$__hookMeta2 = this.__hookMeta,
        effectCbArr = _this$__hookMeta2.effectCbArr,
        effectCbReturnArr = _this$__hookMeta2.effectCbReturnArr,
        effectSeeResult = _this$__hookMeta2.effectSeeResult;
    effectCbArr.forEach(function (cb, idx) {
      var shouldEffectExecute = effectSeeResult[idx];

      if (shouldEffectExecute) {
        var cbReturn = cb();

        if (typeof cbReturn === 'function') {
          effectCbReturnArr[idx] = cbReturn;
        }
      }
    });
  };

  _proto.shouldComponentUpdate = function shouldComponentUpdate() {
    return false;
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.__hookMeta.effectCbReturnArr.forEach(function (cb) {
      if (cb) cb();
    });

    var _this$cc$ccState = this.cc.ccState,
        ccUniqueKey = _this$cc$ccState.ccUniqueKey,
        ccClassKey = _this$cc$ccState.ccClassKey;
    ev.offEventHandlersByCcUniqueKey(ccUniqueKey);
    ccRef.unsetRef(ccClassKey, ccUniqueKey);
    if (_Component.prototype.componentWillUnmount) _Component.prototype.componentWillUnmount.call(this);
  };

  _proto.render = function render() {
    var _this$props = this.props,
        children = _this$props.children,
        render = _this$props.render;
    var view = render || children;

    if (typeof view === 'function') {
      this.__fragmentParams.state = this.state; //注意这里，一定要每次都取最新的

      return view(this.__fragmentParams) || React.createElement(Fragment);
    } else {
      if (React.isValidElement(view)) {
        util.justWarning("you are trying to specify a react dom to be CcFragment's children, it will never been rendered again no matter how your state changed!!!");
      }

      return view;
    }
  };

  return CcFragment;
}(Component);

export { CcFragment as default };