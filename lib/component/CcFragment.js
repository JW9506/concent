"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports["default"] = void 0;

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/inheritsLoose"));

var _react = _interopRequireWildcard(require("react"));

var _constant = require("../support/constant");

var _ccContext = _interopRequireDefault(require("../cc-context"));

var util = _interopRequireWildcard(require("../support/util"));

var _getFeatureStrAndStpmapping = _interopRequireDefault(require("../core/base/get-feature-str-and-stpmapping"));

var ev = _interopRequireWildcard(require("../core/event"));

var ccRef = _interopRequireWildcard(require("../core/ref"));

var base = _interopRequireWildcard(require("../core/base"));

var _extractStateByCcsync2 = _interopRequireDefault(require("../core/state/extract-state-by-ccsync"));

var _watchKeyForRef = _interopRequireDefault(require("../core/watch/watch-key-for-ref"));

var _getWatchSpec = _interopRequireDefault(require("../core/watch/get-watch-spec"));

var _computeValueForRef = _interopRequireDefault(require("../core/computed/compute-value-for-ref"));

var _getComputedSpec = _interopRequireDefault(require("../core/computed/get-computed-spec"));

var ccClassKey_ccClassContext_ = _ccContext["default"].ccClassKey_ccClassContext_,
    fragmentFeature_classKey_ = _ccContext["default"].fragmentFeature_classKey_,
    _ccContext$store = _ccContext["default"].store,
    getState = _ccContext$store.getState,
    getPrevState = _ccContext$store.getPrevState,
    moduleName_stateKeys_ = _ccContext["default"].moduleName_stateKeys_,
    _reducerModule_fnNames_ = _ccContext["default"].reducer._reducerModule_fnNames_;
var okeys = util.okeys;
var seq = 0; //虽然CcFragment实例默认属于$$default模块，但是它的state是独立的，

function getStateModule() {
  seq++;
  return Symbol("__for_cc_fragment_state_" + seq + "__");
}
/**
 * 根据connect参数动态的把CcFragment划为某个ccClassKey的实例，同时计算出stateToPropMapping值
 * @param connectSpec 形如: {foo:'*', bar:['b1', 'b2']}
 */


function getFragmentClassKeyAndStpMapping(connectSpec) {
  if (!util.isObjectNotNull(connectSpec)) {
    //代表没有connect到store任何模块的CcFragment
    return {
      ccClassKey: _constant.CC_FRAGMENT_PREFIX + "_0",
      stateToPropMapping: null
    };
  }

  var _getFeatureStrAndStpM = (0, _getFeatureStrAndStpmapping["default"])(connectSpec),
      featureStr = _getFeatureStrAndStpM.featureStr,
      stateToPropMapping = _getFeatureStrAndStpM.stateToPropMapping,
      connectedModuleNames = _getFeatureStrAndStpM.connectedModuleNames;

  var ccClassKey = fragmentFeature_classKey_[featureStr];

  if (ccClassKey) {
    return {
      ccClassKey: ccClassKey,
      stateToPropMapping: stateToPropMapping,
      connectedModuleNames: connectedModuleNames
    };
  } else {
    var oldFragmentNameCount = _ccContext["default"].fragmentNameCount;
    var fragmentNameCount = oldFragmentNameCount + 1;
    _ccContext["default"].fragmentNameCount = fragmentNameCount;
    ccClassKey = _constant.CC_FRAGMENT_PREFIX + "_" + fragmentNameCount;
    fragmentFeature_classKey_[featureStr] = ccClassKey;
    return {
      ccClassKey: ccClassKey,
      stateToPropMapping: stateToPropMapping,
      connectedModuleNames: connectedModuleNames
    };
  }
}

var idSeq = 0;

function getEId() {
  idSeq++;
  return Symbol("__autoGen_" + idSeq + "__");
}

var CcFragment =
/*#__PURE__*/
function (_Component) {
  (0, _inheritsLoose2["default"])(CcFragment, _Component);

  function CcFragment(props, context) {
    var _this;

    _this = _Component.call(this, props, context) || this;
    _this.__beforeMount = _this.__beforeMount.bind((0, _assertThisInitialized2["default"])(_this));
    var ccKey = props.ccKey,
        _props$connect = props.connect,
        connectSpec = _props$connect === void 0 ? {} : _props$connect,
        _props$state = props.state,
        state = _props$state === void 0 ? {} : _props$state,
        module = props.module; // 自动赋值connect

    if (module && !connectSpec[module]) connectSpec[module] = '*';

    var _getFragmentClassKeyA = getFragmentClassKeyAndStpMapping(connectSpec),
        ccClassKey = _getFragmentClassKeyA.ccClassKey,
        stateToPropMapping = _getFragmentClassKeyA.stateToPropMapping,
        connectedModuleNames = _getFragmentClassKeyA.connectedModuleNames;

    var ccUniqueKey = '',
        isCcUniqueKeyAutoGenerated = false;

    if (ccKey) {
      // for CcFragment, if user supply ccKey to props, ccUniqueKey will equal ccKey
      ccUniqueKey = ccKey;
    } else {
      var _base$computeCcUnique = base.computeCcUniqueKey(false, ccClassKey, ccKey, true),
          ck = _base$computeCcUnique.ccKey,
          cuk = _base$computeCcUnique.ccUniqueKey,
          ag = _base$computeCcUnique.isCcUniqueKeyAutoGenerated;

      ccUniqueKey = cuk;
      isCcUniqueKeyAutoGenerated = ag;
      ccKey = ck;
    }

    var outProps = props.props || props; //把最外层的props传递给用户
    //计算fragment所属的模块

    var fragmentModule = module || okeys(connectSpec)[0] || _constant.MODULE_DEFAULT;

    base.buildCcClassContext(ccClassKey, fragmentModule, [], [], stateToPropMapping, connectedModuleNames, true);
    ccRef.setRef((0, _assertThisInitialized2["default"])(_this), false, ccClassKey, ccKey, ccUniqueKey, {}, true); // for CcFragment, just put ccClassKey to module's cc class keys

    var moduleName_ccClassKeys_ = _ccContext["default"].moduleName_ccClassKeys_;
    var ccClassKeys = util.safeGetArrayFromObject(moduleName_ccClassKeys_, fragmentModule);
    if (!ccClassKeys.includes(ccClassKey)) ccClassKeys.push(ccClassKey);
    var ctx = ccClassKey_ccClassContext_[ccClassKey];
    var connectedComputed = ctx.connectedComputed || {};
    var connectedState = ctx.connectedState || {};
    var moduleState = connectedState[fragmentModule] || {};
    var moduleComputed = connectedComputed[fragmentModule] || {};

    var reactForceUpdateRef = _this.forceUpdate.bind((0, _assertThisInitialized2["default"])(_this));

    var reactSetStateRef = _this.setState.bind((0, _assertThisInitialized2["default"])(_this));

    var refConnectedComputed = {};
    var refComputed = {};
    okeys(connectSpec).forEach(function (moduleName) {
      refConnectedComputed[moduleName] = {};
    });
    var ccState = {
      stateModule: getStateModule(),
      module: fragmentModule,
      ccClassKey: ccClassKey,
      ccKey: ccKey,
      ccUniqueKey: ccUniqueKey,
      isCcUniqueKeyAutoGenerated: isCcUniqueKeyAutoGenerated,
      stateToPropMapping: stateToPropMapping,
      renderCount: 0,
      initTime: Date.now(),
      connect: connectSpec
    };
    _this.cc = {
      // onUrlChanged: null,
      prevState: state,
      ccState: ccState,
      refConnectedComputed: refConnectedComputed,
      refComputed: refComputed,
      watch: null,
      watchSpec: null,
      computed: null,
      computedSpec: null,
      reactForceUpdate: function reactForceUpdate(cb) {
        ccState.renderCount += 1; //方便用户直接绑定forceUpdate

        if (typeof cb !== 'function') reactForceUpdateRef();else reactForceUpdateRef(cb);
      },
      reactSetState: function reactSetState(state, cb) {
        ccState.renderCount += 1;
        reactSetStateRef(state, cb); // reactSetStateRef(state, () => {
        //   if (typeof cb !== 'function') reactForceUpdateRef();
        //   else reactForceUpdateRef(cb);
        // });
      }
    }; // hook implement fo CcFragment

    var __hookMeta = {
      isCcFragmentMounted: false,
      useStateCount: 0,
      useStateCursor: 0,
      stateArr: [],
      useEffectCount: 0,
      useEffectCursor: 0,
      effectCbArr: [],
      effectSeeAoa: [],
      // shouldEffectExecute array of array
      effectSeeResult: [],
      // collect every effect fn's shouldExecute result
      effectCbReturnArr: []
    };
    _this.__hookMeta = __hookMeta;
    var hook = {
      useState: function useState(initialState) {
        var cursor = __hookMeta.useStateCursor;
        var stateArr = __hookMeta.stateArr;
        __hookMeta.useStateCursor++;

        if (__hookMeta.isCcFragmentMounted === false) {
          //render CcFragment before componentDidMount
          __hookMeta.useStateCount++;
          stateArr[cursor] = initialState;
        } else {
          cursor = cursor % __hookMeta.useStateCount;
        }

        var setter = function setter(e) {
          if (e.currentTarget && e.type) {
            var _sync;

            __sync((_sync = {}, _sync[_constant.CURSOR_KEY] = cursor, _sync), e);
          } else {
            stateArr[cursor] = e;

            _this.cc.reactForceUpdate();
          }
        };

        return [stateArr[cursor], setter];
      },
      useEffect: function useEffect(cb, shouldEffectExecute) {
        var cursor = __hookMeta.useEffectCursor;
        __hookMeta.useEffectCursor++;

        if (__hookMeta.isCcFragmentMounted === false) {
          __hookMeta.effectCbArr.push(cb);

          __hookMeta.effectSeeAoa.push(shouldEffectExecute);

          __hookMeta.useEffectCount++;
        } else {
          // if code running jump into this block, CcFragment already mounted, and now compute result for didUpdate
          cursor = cursor % __hookMeta.useEffectCount;

          if (Array.isArray(shouldEffectExecute)) {
            var len = shouldEffectExecute.length;

            if (len == 0) {
              __hookMeta.effectSeeResult[cursor] = false; // effect fn will been executed only in didMount
            } else {
              // compare prevSee and curSee
              var effectSeeResult = false;
              var prevSeeArr = __hookMeta.effectSeeAoa[cursor];

              if (!prevSeeArr) {
                effectSeeResult = true;
              } else {
                for (var i = 0; i < len; i++) {
                  if (shouldEffectExecute[i] !== prevSeeArr[i]) {
                    effectSeeResult = true;
                    break;
                  }
                }
              }

              __hookMeta.effectSeeAoa[cursor] = shouldEffectExecute;
              __hookMeta.effectSeeResult[cursor] = effectSeeResult;
              if (effectSeeResult) __hookMeta.effectCbArr[cursor] = cb;
            }
          } else {
            __hookMeta.effectSeeResult[cursor] = true; // effect fn will always been executed in didMount and didUpdate

            __hookMeta.effectSeeAoa[cursor] = shouldEffectExecute;
            __hookMeta.effectCbArr[cursor] = cb;
          }
        }
      }
    };
    var dispatcher = ccRef.getDispatcherRef();
    _this.state = state;

    var __sync = function __sync(spec, e) {
      if (spec[_constant.CURSOR_KEY] !== undefined) {
        //来自hook生成的setter调用
        var _cursor = spec[_constant.CURSOR_KEY];
        __hookMeta.stateArr[_cursor] = e.currentTarget.value;

        _this.cc.reactForceUpdate();

        return;
      }

      var mockE = base.buildMockEvent(spec, e, _constant.STATE_FOR_ALL_CC_INSTANCES_OF_ONE_MODULE);
      if (!mockE) return; //参数无效

      var currentTarget = mockE.currentTarget;
      var dataset = currentTarget.dataset;
      if (e && e.stopPropagation) e.stopPropagation();
      var ccsync = dataset.ccsync;

      if (ccsync.startsWith('/')) {
        dataset.ccsync = "" + _this.cc.ccState.module + ccsync; //附加上默认模块值
      }

      if (ccsync.includes('/')) {
        // syncModuleState 同步模块的state状态
        dispatcher.$$sync(mockE);
      } else {
        // syncLocalState 同步本地的state状态
        var _extractStateByCcsync = (0, _extractStateByCcsync2["default"])(dataset.ccsync, currentTarget.value, dataset.ccint, _this.state, mockE.isToggleBool),
            _state2 = _extractStateByCcsync.state;

        __fragmentParams.setState(_state2);
      }
    };

    var effectItems = []; // {fn:function, status:0, eId:'', immediate:true}

    var eid_effectReturnCb_ = {}; // fn

    _this.__staticEffectMeta = {
      effectItems: effectItems,
      eid_effectReturnCb_: eid_effectReturnCb_
    };
    var isWatchDefined = false;
    var isComputedDefined = false;
    var __fragmentParams = {
      module: fragmentModule,
      isCcFragment: true,
      refComputed: refComputed,
      refConnectedComputed: refConnectedComputed,
      connectedComputed: connectedComputed,
      connectedState: connectedState,
      moduleState: moduleState,
      moduleComputed: moduleComputed,
      // 新增defineEffect相关的支持
      defineEffect: function defineEffect(fn, stateKeys, eId, immediate) {
        if (immediate === void 0) {
          immediate = true;
        }

        if (typeof fn !== 'function') throw new Error('type of defineEffect first param must be function');

        if (stateKeys !== null && stateKeys !== undefined) {
          if (!Array.isArray(stateKeys)) throw new Error('type of defineEffect second param must be one of them(array, null, undefined)');
        }

        var _fn = fn.bind((0, _assertThisInitialized2["default"])(_this), _this.__fragmentParams, outProps);

        var _eId = eId || getEId();

        var effectItem = {
          fn: _fn,
          stateKeys: stateKeys,
          status: _constant.EFFECT_AVAILABLE,
          eId: _eId,
          immediate: immediate
        };
        effectItems.push(effectItem);
      },
      stopEffect: function stopEffect(eId) {
        var target = effectItems.find(function (v) {
          return v.eId === eId;
        });
        if (target) target.status = _constant.EFFECT_STOPPED;
      },
      resumeEffect: function resumeEffect(eId) {
        var target = effectItems.find(function (v) {
          return v.eId === eId;
        });
        if (target) target.status = _constant.EFFECT_AVAILABLE;
      },
      removeEffect: function removeEffect(eId) {
        var targetIdx = effectItems.findIndex(function (v) {
          return v.eId === eId;
        });
        if (targetIdx >= 0) effectItems.splice(targetIdx, 1);
      },
      stopAllEffect: function stopAllEffect() {
        effectItems.forEach(function (v) {
          return v.status = _constant.EFFECT_STOPPED;
        });
      },
      resumeAllEffect: function resumeAllEffect() {
        effectItems.forEach(function (v) {
          return v.status = _constant.EFFECT_AVAILABLE;
        });
      },
      removeAllEffect: function removeAllEffect() {
        effectItems.length = 0;
      },
      defineWatch: function defineWatch(watch) {
        if (isWatchDefined) throw new Error('defineWatch can only been one time');
        var watchSpec = (0, _getWatchSpec["default"])(watch, _this.__fragmentParams, _this.cc.ccState.module);
        _this.cc.watch = watch;
        _this.cc.watchSpec = watchSpec;
      },
      defineComputed: function defineComputed(computed) {
        if (isComputedDefined) throw new Error('defineComputed can only been one time');
        var computedSpec = (0, _getComputedSpec["default"])(computed, _this.__fragmentParams, _this.cc.ccState.module);
        _this.cc.computed = computed;
        _this.cc.computedSpec = computedSpec;
      },
      settings: {},
      reducer: {},
      lazyReducer: {},
      // ------ end ------
      //对布尔值自动取反
      syncBool: function syncBool(e, delay, idt) {
        var _sync$bind;

        if (delay === void 0) {
          delay = -1;
        }

        if (idt === void 0) {
          idt = '';
        }

        if (typeof e === 'string') return __sync.bind(null, (_sync$bind = {}, _sync$bind[_constant.CCSYNC_KEY] = e, _sync$bind.type = 'bool', _sync$bind.delay = delay, _sync$bind.idt = idt, _sync$bind));

        __sync({
          type: 'bool'
        }, e);
      },
      //if <Input onChange={(value:string, value2:string)=>void} />
      // <Input onChange={ctx.sync} /> not work!!!
      // <Input onChange={ctx.sync('foo/f1')} /> ok
      // only <input data-ccsync="foo/f1" onChange={ctx.sync} /> ok
      // only <input onChange={ctx.sync('foo/f1')} /> ok
      sync: function sync(e, val, delay, idt) {
        var _sync$bind2;

        if (delay === void 0) {
          delay = -1;
        }

        if (idt === void 0) {
          idt = '';
        }

        if (typeof e === 'string') return __sync.bind(null, (_sync$bind2 = {}, _sync$bind2[_constant.CCSYNC_KEY] = e, _sync$bind2.type = 'val', _sync$bind2.val = val, _sync$bind2.delay = delay, _sync$bind2.idt = idt, _sync$bind2));

        __sync({
          type: 'val'
        }, e); //allow <input data-ccsync="foo/f1" onChange={ctx.sync} />

      },
      //因为val可以是任意类型值，所以不再需要提供setInt
      set: function set(ccsync, val, delay, idt) {
        var _sync2;

        __sync((_sync2 = {}, _sync2[_constant.CCSYNC_KEY] = ccsync, _sync2.type = 'val', _sync2.val = val, _sync2.delay = delay, _sync2.idt = idt, _sync2));
      },
      //对布尔值自动取反
      setBool: function setBool(ccsync, delay, idt) {
        var _sync3;

        if (delay === void 0) {
          delay = -1;
        }

        if (idt === void 0) {
          idt = '';
        }

        __sync((_sync3 = {}, _sync3[_constant.CCSYNC_KEY] = ccsync, _sync3.type = 'bool', _sync3.delay = delay, _sync3.idt = idt, _sync3));
      },
      // <Input onChange={ctx.syncInt} /> not work!!!
      // <Input onChange={ctx.syncInt('foo/bar')} /> ok
      // <input onChange={ctx.syncInt('foo/bar')} /> ok
      // <input data-ccsync="foo/f1" onChange={ctx.syncInt('foo/fq')} /> ok
      syncInt: function syncInt(e, delay, idt) {
        var _sync$bind3;

        if (delay === void 0) {
          delay = -1;
        }

        if (idt === void 0) {
          idt = '';
        }

        if (typeof e === 'string') return __sync.bind(null, (_sync$bind3 = {}, _sync$bind3[_constant.CCSYNC_KEY] = e, _sync$bind3.type = 'int', _sync$bind3.delay = delay, _sync$bind3.idt = idt, _sync$bind3));

        __sync({
          type: 'int'
        }, e); //<input data-ccsync="foo/f1" onChange={ctx.syncInt} />

      },
      onUrlChanged: function onUrlChanged(cb) {
        _this.cc.onUrlChanged = cb.bind((0, _assertThisInitialized2["default"])(_this));
      },
      hook: hook,
      emit: function emit(event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        ev.findEventHandlersToPerform.apply(ev, [event, {
          identity: null
        }].concat(args));
      },
      emitIdentity: function emitIdentity(event, identity) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
          args[_key2 - 2] = arguments[_key2];
        }

        ev.findEventHandlersToPerform.apply(ev, [event, {
          identity: identity
        }].concat(args));
      },
      on: function on(event, handler) {
        ev.bindEventHandlerToCcContext(_this.cc.ccState.module, ccClassKey, ccUniqueKey, event, null, handler);
      },
      onIdentity: function onIdentity(event, identity, handler) {
        ev.bindEventHandlerToCcContext(_this.cc.ccState.module, ccClassKey, ccUniqueKey, event, identity, handler);
      },
      dispatch: function dispatch(paramObj, payloadWhenFirstParamIsString, userInputDelay, userInputIdentity) {
        var stateModule = _this.cc.ccState.module;

        var d = dispatcher.__$$getDispatchHandler(_this.state, false, ccKey, ccUniqueKey, ccClassKey, _constant.STATE_FOR_ALL_CC_INSTANCES_OF_ONE_MODULE, stateModule, stateModule, null, null, -1);

        d(paramObj, payloadWhenFirstParamIsString, userInputDelay, userInputIdentity);
      },
      lazyDispatch: function lazyDispatch(paramObj, payloadWhenFirstParamIsString, userInputDelay, userInputIdentity) {
        var stateModule = _this.cc.ccState.module;

        var d = dispatcher.__$$getDispatchHandler(_this.state, true, ccKey, ccUniqueKey, ccClassKey, _constant.STATE_FOR_ALL_CC_INSTANCES_OF_ONE_MODULE, stateModule, stateModule, null, null, -1);

        d(paramObj, payloadWhenFirstParamIsString, userInputDelay, userInputIdentity);
      },
      callDispatch: function callDispatch() {
        var _this$__fragmentParam;

        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        return (_this$__fragmentParam = _this.__fragmentParams.dispatch).bind.apply(_this$__fragmentParam, [(0, _assertThisInitialized2["default"])(_this)].concat(args));
      },
      callLazyDispatch: function callLazyDispatch() {
        var _this$__fragmentParam2;

        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        return (_this$__fragmentParam2 = _this.__fragmentParams.lazyDispatch).bind.apply(_this$__fragmentParam2, [(0, _assertThisInitialized2["default"])(_this)].concat(args));
      },
      effect: dispatcher.__$$getEffectHandler(ccKey),
      xeffect: dispatcher.__$$getXEffectHandler(ccKey),
      setModuleState: function setModuleState(module, state, delay, identity) {
        var _module = module,
            _state = state,
            _delay = delay,
            _identity = identity;

        if (typeof module === 'object') {
          _module = _this.cc.ccState.module;
          _state = module;
          _delay = state;
          _identity = delay;
        }

        dispatcher.$$changeState(_state, {
          ccKey: ccKey,
          module: _module,
          stateFor: _constant.STATE_FOR_ALL_CC_INSTANCES_OF_ONE_MODULE,
          delay: _delay,
          identity: _identity
        });
      },
      setGlobalState: function setGlobalState(state, delay, identity) {
        _this.__fragmentParams.setModuleState(_constant.MODULE_GLOBAL, state, delay, identity);
      },
      state: state,
      props: outProps,
      fragmentProps: props,
      setState: function setState(state, cb) {
        var thisCc = _this.cc;
        var thisState = _this.state;
        var _thisCc$ccState = thisCc.ccState,
            stateModule = _thisCc$ccState.stateModule,
            connect = _thisCc$ccState.connect;
        (0, _computeValueForRef["default"])(stateModule, thisCc.computedSpec, thisCc.refComputed, thisCc.refConnectedComputed, thisState, state, __fragmentParams, true);
        var shouldCurrentRefUpdate = (0, _watchKeyForRef["default"])(stateModule, thisCc.watchSpec, connect, thisState, state, _this.__fragmentParams);
        if (shouldCurrentRefUpdate) _this.cc.reactSetState(state, cb);
      },
      forceUpdate: function forceUpdate(cb) {
        _this.__fragmentParams.setState(_this.state, cb);
      }
    };
    _this.__fragmentParams = __fragmentParams;

    _this.__beforeMount();

    return _this;
  }

  var _proto = CcFragment.prototype;

  _proto.__beforeMount = function __beforeMount() {
    var _this2 = this;

    var _this$props = this.props,
        setup = _this$props.setup,
        bindCtxToMethod = _this$props.bindCtxToMethod;
    var ctx = this.__fragmentParams;
    var reducer = ctx.reducer;
    var lazyReducer = ctx.lazyReducer;
    var thisCc = this.cc;
    var thisState = this.state;
    var _thisCc$ccState2 = thisCc.ccState,
        stateModule = _thisCc$ccState2.stateModule,
        connect = _thisCc$ccState2.connect;
    var dispatch = this.__fragmentParams.dispatch;
    var lazyDispatch = this.__fragmentParams.lazyDispatch;
    var connectModules = okeys(connect); //向实例的reducer里绑定方法，key:{module} value:{reducerFn}

    connectModules.forEach(function (m) {
      var refReducerFnObj = util.safeGetObjectFromObject(reducer, m);
      var refLazyReducerFnObj = util.safeGetObjectFromObject(lazyReducer, m);
      var fnNames = _reducerModule_fnNames_[m] || [];
      fnNames.forEach(function (fnName) {
        refReducerFnObj[fnName] = function (payload, delay, idt) {
          return dispatch(m + "/" + fnName, payload, delay, idt);
        };

        refLazyReducerFnObj[fnName] = function (payload, delay, idt) {
          return lazyDispatch(m + "/" + fnName, payload, delay, idt);
        };
      });
    }); //先调用setup，setup可能会定义computed,watch，同时也可能调用ctx.reducer,所以setup放在fill reducer之后，分析computedSpec之前

    if (setup) {
      if (typeof setup !== 'function') throw new Error('type of setup must be function');
      var settingsObj = setup(this.__fragmentParams) || {};
      if (!util.isPlainJsonObject(settingsObj)) throw new Error('type of setup return result must be an plain json object');
      var globalBindCtx = _ccContext["default"].bindCtxToMethod; //优先读自己的，再读全局的

      if (bindCtxToMethod === true || globalBindCtx === true && bindCtxToMethod !== false) {
        okeys(settingsObj).forEach(function (name) {
          var settingValue = settingsObj[name];
          if (typeof settingValue === 'function') settingsObj[name] = settingValue.bind(_this2, ctx);
        });
      }

      ctx.settings = settingsObj;
    }

    var computedSpec = thisCc.computedSpec; //触发计算computed

    if (computedSpec) {
      var refComputed = thisCc.refComputed,
          refConnectedComputed = thisCc.refConnectedComputed; //这里操作的是moduleState，最后一个参数置为true，让无模块的stateKey的计算值能写到refComputed里,

      (0, _computeValueForRef["default"])(stateModule, computedSpec, refComputed, refConnectedComputed, thisState, thisState, this.__fragmentParams, true);
      connectModules.forEach(function (m) {
        var mState = getState(m);
        (0, _computeValueForRef["default"])(m, computedSpec, refComputed, refConnectedComputed, mState, mState, _this2.__fragmentParams);
      });
    }
  };

  _proto.executeHookEffect = function executeHookEffect(callByDidMount) {
    var ctx = this.__fragmentParams;
    var _this$__hookMeta = this.__hookMeta,
        effectCbArr = _this$__hookMeta.effectCbArr,
        effectCbReturnArr = _this$__hookMeta.effectCbReturnArr;

    if (callByDidMount) {
      this.__hookMeta.isCcFragmentMounted = true;
      effectCbArr.forEach(function (cb) {
        var cbReturn = cb(ctx);

        if (typeof cbReturn === 'function') {
          effectCbReturnArr.push(cbReturn);
        } else {
          effectCbReturnArr.push(null);
        }
      });
    } else {
      var effectSeeResult = this.__hookMeta.effectSeeResult;
      effectCbArr.forEach(function (cb, idx) {
        var shouldEffectExecute = effectSeeResult[idx];

        if (shouldEffectExecute) {
          var cbReturn = cb(ctx);

          if (typeof cbReturn === 'function') {
            effectCbReturnArr[idx] = cbReturn;
          }
        }
      });
    }
  };

  _proto.executeSetupEffect = function executeSetupEffect(callByDidMount) {
    var _this$__staticEffectM = this.__staticEffectMeta,
        effectItems = _this$__staticEffectM.effectItems,
        eid_effectReturnCb_ = _this$__staticEffectM.eid_effectReturnCb_;
    var ctx = this.__fragmentParams;

    if (callByDidMount) {
      effectItems.forEach(function (item) {
        if (item.immediate === false) return;
        var cb = item.fn(ctx);
        if (cb) eid_effectReturnCb_[item.eId] = cb;
      });
    } else {
      //callByDidUpdate
      var prevState = this.cc.prevState;
      var curState = this.state;
      effectItems.forEach(function (item) {
        var status = item.status,
            stateKeys = item.stateKeys,
            fn = item.fn,
            eId = item.eId;
        if (status === _constant.EFFECT_STOPPED) return;

        if (stateKeys) {
          var keysLen = stateKeys.length;
          if (keysLen === 0) return;
          var shouldEffectExecute = false;

          for (var i = 0; i < keysLen; i++) {
            var key = stateKeys[i];
            var targetCurState = void 0,
                targetPrevState = void 0,
                targetKey = void 0;

            if (key.includes('/')) {
              var _key$split = key.split('/'),
                  module = _key$split[0],
                  unmoduledKey = _key$split[1];

              var _prevState = getPrevState(module);

              if (!_prevState) {
                util.justWarning("key[" + key + "] is invalid, its module[" + module + "] has not been declared in store!");
                continue;
              }

              if (!moduleName_stateKeys_[module].includes(unmoduledKey)) {
                util.justWarning("key[" + key + "] is invalid, its unmoduledKey[" + unmoduledKey + "] has not been declared in state!");
                continue;
              }

              targetCurState = getState(module);
              targetPrevState = _prevState;
              targetKey = unmoduledKey;
            } else {
              targetCurState = curState;
              targetPrevState = prevState;
              targetKey = key;
            }

            if (targetPrevState[targetKey] !== targetCurState[targetKey]) {
              shouldEffectExecute = true;
              break;
            }
          }

          if (shouldEffectExecute) {
            var cb = fn(ctx);
            if (cb) eid_effectReturnCb_[eId] = cb;
          }
        } else {
          var _cb = fn(ctx);

          if (_cb) eid_effectReturnCb_[eId] = _cb;
        }
      });
    }
  };

  _proto.componentDidMount = function componentDidMount() {
    this.executeSetupEffect(true);
    this.executeHookEffect(true);
  };

  _proto.shouldComponentUpdate = function shouldComponentUpdate(_, nextState) {
    var curState = this.state;
    this.cc.prevState = curState;
    return curState !== nextState;
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    this.executeSetupEffect();
    this.executeHookEffect();
    this.cc.prevState = this.state; //!!!  重置prevState，防止其他模块的更新操作再次执行executeSetupEffect时，判断shouldEffectExecute失效
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    var ctx = this.__fragmentParams;

    this.__hookMeta.effectCbReturnArr.forEach(function (cb) {
      if (typeof cb === 'function') cb(ctx);
    });

    var eid_effectReturnCb_ = this.__staticEffectMeta.eid_effectReturnCb_;
    Object.getOwnPropertySymbols(eid_effectReturnCb_).forEach(function (symbolKey) {
      var cb = eid_effectReturnCb_[symbolKey];
      if (typeof cb === 'function') cb(ctx);
    });
    okeys(eid_effectReturnCb_).forEach(function (eId) {
      var cb = eid_effectReturnCb_[eId];
      if (typeof cb === 'function') cb(ctx);
    });
    var _this$cc$ccState = this.cc.ccState,
        ccUniqueKey = _this$cc$ccState.ccUniqueKey,
        ccClassKey = _this$cc$ccState.ccClassKey;
    ev.offEventHandlersByCcUniqueKey(ccUniqueKey);
    ccRef.unsetRef(ccClassKey, ccUniqueKey);
    if (_Component.prototype.componentWillUnmount) _Component.prototype.componentWillUnmount.call(this);
  };

  _proto.render = function render() {
    var _this$props2 = this.props,
        children = _this$props2.children,
        render = _this$props2.render;
    var view = render || children;

    if (typeof view === 'function') {
      this.__fragmentParams.state = this.state; //注意这里，一定要每次都取最新的

      return view(this.__fragmentParams) || _react["default"].createElement(_react.Fragment);
    } else {
      if (_react["default"].isValidElement(view)) {
        util.justWarning("you are trying to specify a react dom to be CcFragment's children, it will never been rendered again no matter how your state changed!!!");
      }

      return view;
    }
  };

  return CcFragment;
}(_react.Component);

exports["default"] = CcFragment;