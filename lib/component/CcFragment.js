"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports["default"] = void 0;

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/inheritsLoose"));

var _react = _interopRequireWildcard(require("react"));

var _constant = require("../support/constant");

var _ccContext = _interopRequireDefault(require("../cc-context"));

var util = _interopRequireWildcard(require("../support/util"));

var _getFeatureStrAndStpmapping = _interopRequireDefault(require("../core/base/get-feature-str-and-stpmapping"));

var ev = _interopRequireWildcard(require("../core/event"));

var ccRef = _interopRequireWildcard(require("../core/ref"));

var base = _interopRequireWildcard(require("../core/base"));

var _extractStateByCcsync2 = _interopRequireDefault(require("../core/state/extract-state-by-ccsync"));

var _watchKeyForRef = _interopRequireDefault(require("../core/watch/watch-key-for-ref"));

var _getWatchSpec = _interopRequireDefault(require("../core/watch/get-watch-spec"));

var _computeValueForRef = _interopRequireDefault(require("../core/computed/compute-value-for-ref"));

var _getComputedSpec = _interopRequireDefault(require("../core/computed/get-computed-spec"));

var ccClassKey_ccClassContext_ = _ccContext["default"].ccClassKey_ccClassContext_,
    fragmentFeature_classKey_ = _ccContext["default"].fragmentFeature_classKey_,
    computed = _ccContext["default"].computed,
    _ccContext$store = _ccContext["default"].store,
    getState = _ccContext$store.getState,
    getPrevState = _ccContext$store.getPrevState,
    moduleName_stateKeys_ = _ccContext["default"].moduleName_stateKeys_;
var seq = 0; //虽然CcFragment实例默认属于$$default模块，但是它的state是独立的，

function getStateModule() {
  seq++;
  return Symbol("__for_cc_fragment_state_" + seq + "__");
}
/**
 * 根据connect参数动态的把CcFragment划为某个ccClassKey的实例，同时计算出stateToPropMapping值
 * @param connectSpec 形如: {foo:'*', bar:['b1', 'b2']}
 */


function getFragmentClassKeyAndStpMapping(connectSpec) {
  if (!util.isObjectNotNull(connectSpec)) {
    //代表没有connect到store任何模块的CcFragment
    return {
      ccClassKey: _constant.CC_FRAGMENT_PREFIX + "_0",
      stateToPropMapping: null
    };
  }

  var _getFeatureStrAndStpM = (0, _getFeatureStrAndStpmapping["default"])(connectSpec),
      featureStr = _getFeatureStrAndStpM.featureStr,
      stateToPropMapping = _getFeatureStrAndStpM.stateToPropMapping;

  var ccClassKey = fragmentFeature_classKey_[featureStr];

  if (ccClassKey) {
    return {
      ccClassKey: ccClassKey,
      stateToPropMapping: stateToPropMapping
    };
  } else {
    var oldFragmentNameCount = _ccContext["default"].fragmentNameCount;
    var fragmentNameCount = oldFragmentNameCount + 1;
    _ccContext["default"].fragmentNameCount = fragmentNameCount;
    ccClassKey = _constant.CC_FRAGMENT_PREFIX + "_" + fragmentNameCount;
    fragmentFeature_classKey_[featureStr] = ccClassKey;
    return {
      ccClassKey: ccClassKey,
      stateToPropMapping: stateToPropMapping
    };
  }
}

var cursorKey = _constant.CURSOR_KEY;
var ccSyncKey = _constant.CCSYNC_KEY;
var idSeq = 0;

function getEId() {
  idSeq++;
  return Symbol("__autoGen_" + idSeq + "__");
}

var CcFragment =
/*#__PURE__*/
function (_Component) {
  (0, _inheritsLoose2["default"])(CcFragment, _Component);

  function CcFragment(props, context) {
    var _this;

    _this = _Component.call(this, props, context) || this;
    var ccKey = props.ccKey,
        _props$connect = props.connect,
        connectSpec = _props$connect === void 0 ? {} : _props$connect,
        _props$state = props.state,
        state = _props$state === void 0 ? {} : _props$state;

    var _getFragmentClassKeyA = getFragmentClassKeyAndStpMapping(connectSpec),
        ccClassKey = _getFragmentClassKeyA.ccClassKey,
        stateToPropMapping = _getFragmentClassKeyA.stateToPropMapping;

    var ccUniqueKey = '',
        isCcUniqueKeyAutoGenerated = false;

    if (ccKey) {
      // for CcFragment, if user supply ccKey to props, ccUniqueKey will equal ccKey
      ccUniqueKey = ccKey;
    } else {
      var _base$computeCcUnique = base.computeCcUniqueKey(false, ccClassKey, ccKey, true),
          ck = _base$computeCcUnique.ccKey,
          cuk = _base$computeCcUnique.ccUniqueKey,
          ag = _base$computeCcUnique.isCcUniqueKeyAutoGenerated;

      ccUniqueKey = cuk;
      isCcUniqueKeyAutoGenerated = ag;
      ccKey = ck;
    }

    var outProps = props.props || props; //把最外层的props传递给用户

    base.buildCcClassContext(ccClassKey, _constant.MODULE_DEFAULT, [], [], [], [], stateToPropMapping, true);
    ccRef.setRef((0, _assertThisInitialized2["default"])(_this), false, ccClassKey, ccKey, ccUniqueKey, {}, true); // for CcFragment, just put ccClassKey to module's cc class keys

    var moduleName_ccClassKeys_ = _ccContext["default"].moduleName_ccClassKeys_;
    var ccClassKeys = util.safeGetArrayFromObject(moduleName_ccClassKeys_, _constant.MODULE_DEFAULT);
    if (!ccClassKeys.includes(ccClassKey)) ccClassKeys.push(ccClassKey);
    var ctx = ccClassKey_ccClassContext_[ccClassKey];
    var connectedComputed = ctx.connectedComputed || {};
    var connectedState = ctx.connectedState || {};

    var reactForceUpdateRef = _this.forceUpdate.bind((0, _assertThisInitialized2["default"])(_this));

    var reactSetStateRef = _this.setState.bind((0, _assertThisInitialized2["default"])(_this));

    var refConnectedComputed = {};
    var refComputed = {};
    util.okeys(connectSpec).forEach(function (moduleName) {
      refConnectedComputed[moduleName] = {};
    });
    var ccState = {
      stateModule: getStateModule(),
      module: _constant.MODULE_DEFAULT,
      ccClassKey: ccClassKey,
      ccKey: ccKey,
      ccUniqueKey: ccUniqueKey,
      isCcUniqueKeyAutoGenerated: isCcUniqueKeyAutoGenerated,
      stateToPropMapping: stateToPropMapping,
      renderCount: 0,
      initTime: Date.now(),
      connect: connectSpec
    };
    _this.cc = {
      // onUrlChanged: null,
      prevState: state,
      ccState: ccState,
      refConnectedComputed: refConnectedComputed,
      refComputed: refComputed,
      watch: null,
      watchSpec: null,
      computed: null,
      computedSpec: null,
      reactForceUpdate: function reactForceUpdate(cb) {
        ccState.renderCount += 1; //方便用户直接绑定forceUpdate

        if (typeof cb !== 'function') reactForceUpdateRef();else reactForceUpdateRef(cb);
      },
      reactSetState: function reactSetState(state, cb) {
        ccState.renderCount += 1;
        reactSetStateRef(state, cb); // reactSetStateRef(state, () => {
        //   if (typeof cb !== 'function') reactForceUpdateRef();
        //   else reactForceUpdateRef(cb);
        // });
      }
    }; // hook implement fo CcFragment

    var __hookMeta = {
      isCcFragmentMounted: false,
      useStateCount: 0,
      useStateCursor: 0,
      stateArr: [],
      useEffectCount: 0,
      useEffectCursor: 0,
      effectCbArr: [],
      effectSeeAoa: [],
      // shouldEffectExecute array of array
      effectSeeResult: [],
      // collect every effect fn's shouldExecute result
      effectCbReturnArr: []
    };
    _this.__hookMeta = __hookMeta;
    var hook = {
      useState: function useState(initialState) {
        var cursor = __hookMeta.useStateCursor;
        var stateArr = __hookMeta.stateArr;
        __hookMeta.useStateCursor++;

        if (__hookMeta.isCcFragmentMounted === false) {
          //render CcFragment before componentDidMount
          __hookMeta.useStateCount++;
          stateArr[cursor] = initialState;
        } else {
          cursor = cursor % __hookMeta.useStateCount;
        }

        var setter = function setter(e) {
          if (e.currentTarget && e.type) {
            var _sync;

            __sync((_sync = {}, _sync[cursorKey] = cursor, _sync), e);
          } else {
            stateArr[cursor] = e;

            _this.cc.reactForceUpdate();
          }
        };

        return [stateArr[cursor], setter];
      },
      useEffect: function useEffect(cb, shouldEffectExecute) {
        var cursor = __hookMeta.useEffectCursor;
        __hookMeta.useEffectCursor++;

        if (__hookMeta.isCcFragmentMounted === false) {
          __hookMeta.effectCbArr.push(cb);

          __hookMeta.effectSeeAoa.push(shouldEffectExecute);

          __hookMeta.useEffectCount++;
        } else {
          // if code running jump into this block, CcFragment already mounted, and now compute result for didUpdate
          cursor = cursor % __hookMeta.useEffectCount;

          if (Array.isArray(shouldEffectExecute)) {
            var len = shouldEffectExecute.length;

            if (len == 0) {
              __hookMeta.effectSeeResult[cursor] = false; // effect fn will been executed only in didMount
            } else {
              // compare prevSee and curSee
              var effectSeeResult = false;
              var prevSeeArr = __hookMeta.effectSeeAoa[cursor];

              if (!prevSeeArr) {
                effectSeeResult = true;
              } else {
                for (var i = 0; i < len; i++) {
                  if (shouldEffectExecute[i] !== prevSeeArr[i]) {
                    effectSeeResult = true;
                    break;
                  }
                }
              }

              __hookMeta.effectSeeAoa[cursor] = shouldEffectExecute;
              __hookMeta.effectSeeResult[cursor] = effectSeeResult;
              if (effectSeeResult) __hookMeta.effectCbArr[cursor] = cb;
            }
          } else {
            __hookMeta.effectSeeResult[cursor] = true; // effect fn will always been executed in didMount and didUpdate

            __hookMeta.effectSeeAoa[cursor] = shouldEffectExecute;
            __hookMeta.effectCbArr[cursor] = cb;
          }
        }
      }
    };
    var dispatcher = ccRef.getDispatcherRef();
    _this.state = state;

    var __sync = function __sync(spec, e) {
      if (spec[cursorKey] !== undefined) {
        //来自hook生成的setter调用
        var _cursor = spec[cursorKey];
        __hookMeta.stateArr[_cursor] = e.currentTarget.value;

        _this.cc.reactForceUpdate();

        return;
      }

      var mockE = base.buildMockEvent(spec, e, _constant.STATE_FOR_ALL_CC_INSTANCES_OF_ONE_MODULE);
      if (!mockE) return; //参数无效

      var currentTarget = mockE.currentTarget;
      var dataset = currentTarget.dataset;
      if (e && e.stopPropagation) e.stopPropagation();

      if (dataset.ccsync.includes('/')) {
        // syncModuleState 同步模块的state状态
        dispatcher.$$sync(mockE);
      } else {
        // syncLocalState 同步本地的state状态
        var _extractStateByCcsync = (0, _extractStateByCcsync2["default"])(dataset.ccsync, currentTarget.value, dataset.ccint, _this.state, mockE.isToggleBool),
            _state = _extractStateByCcsync.state;

        __fragmentParams.setState(_state);
      }
    };

    var effectItems = []; // {fn:function, status:0, eId:'', immediate:true}

    var effectReturnCbs = []; // {fn:function, status:0, eId:'', immediate:true}

    _this.__staticEffectMeta = {
      effectItems: effectItems,
      effectReturnCbs: effectReturnCbs
    };
    var isWatchDefined = false;
    var isComputedDefined = false;
    var __fragmentParams = {
      isCcFragment: true,
      refComputed: refComputed,
      refConnectedComputed: refConnectedComputed,
      connectedComputed: connectedComputed,
      connectedState: connectedState,
      // 新增defineEffect相关的支持
      defineEffect: function defineEffect(fn, stateKeys, eId, immediate) {
        if (immediate === void 0) {
          immediate = true;
        }

        if (typeof fn !== 'function') throw new Error('type of defineEffect first param must be function');

        if (stateKeys !== null && stateKeys !== undefined) {
          if (!Array.isArray(stateKeys)) throw new Error('type of defineEffect second param must be one of them(array, null, undefined)');
        }

        var _fn = fn.bind((0, _assertThisInitialized2["default"])(_this), _this.__fragmentParams, outProps);

        var _eId = eId || getEId();

        var effectItem = {
          fn: _fn,
          stateKeys: stateKeys,
          status: _constant.EFFECT_AVAILABLE,
          eId: _eId,
          immediate: immediate
        };
        effectItems.push(effectItem);
      },
      stopEffect: function stopEffect(eId) {
        var target = effectItems.find(function (v) {
          return v.eId === eId;
        });
        if (target) target.status = _constant.EFFECT_STOPPED;
      },
      resumeEffect: function resumeEffect(eId) {
        var target = effectItems.find(function (v) {
          return v.eId === eId;
        });
        if (target) target.status = _constant.EFFECT_AVAILABLE;
      },
      removeEffect: function removeEffect(eId) {
        var targetIdx = effectItems.findIndex(function (v) {
          return v.eId === eId;
        });
        if (targetIdx >= 0) effectItems.splice(targetIdx, 1);
      },
      stopAllEffect: function stopAllEffect() {
        effectItems.forEach(function (v) {
          return v.status = _constant.EFFECT_STOPPED;
        });
      },
      resumeAllEffect: function resumeAllEffect() {
        effectItems.forEach(function (v) {
          return v.status = _constant.EFFECT_AVAILABLE;
        });
      },
      removeAllEffect: function removeAllEffect() {
        effectItems.length = 0;
      },
      defineWatch: function defineWatch(watch) {
        if (isWatchDefined) throw new Error('defineWatch can only been one time');
        var watchSpec = (0, _getWatchSpec["default"])(watch, _this.__fragmentParams);
        _this.cc.watch = watch;
        _this.cc.watchSpec = watchSpec;
      },
      defineComputed: function defineComputed(computed) {
        if (isComputedDefined) throw new Error('defineComputed can only been one time');
        var computedSpec = (0, _getComputedSpec["default"])(computed, _this.__fragmentParams);
        _this.cc.computed = computed;
        _this.cc.computedSpec = computedSpec;
      },
      method: {},
      // ------ end ------
      toggleBool: function toggleBool(e, delay, idt) {
        var _sync$bind;

        if (delay === void 0) {
          delay = -1;
        }

        if (idt === void 0) {
          idt = '';
        }

        if (typeof e === 'string') return __sync.bind(null, (_sync$bind = {}, _sync$bind[ccSyncKey] = e, _sync$bind.type = 'bool', _sync$bind.delay = delay, _sync$bind.idt = idt, _sync$bind));

        __sync({
          type: 'bool'
        }, e);
      },
      //if <Input onChange={(value:string, value2:string)=>void} />
      // <Input onChange={this.sync} /> not work!!!
      // <Input onChange={this.sync('foo/f1')} /> ok
      // only <input data-ccsync="foo/f1" onChange={this.sync} /> ok
      // only <input onChange={this.sync('foo/f1')} /> ok
      sync: function sync(e, val, delay, idt) {
        var _sync$bind2;

        if (delay === void 0) {
          delay = -1;
        }

        if (idt === void 0) {
          idt = '';
        }

        if (typeof e === 'string') return __sync.bind(null, (_sync$bind2 = {}, _sync$bind2[ccSyncKey] = e, _sync$bind2.type = 'val', _sync$bind2.val = val, _sync$bind2.delay = delay, _sync$bind2.idt = idt, _sync$bind2));

        __sync({
          type: 'val'
        }, e); //allow <input data-ccsync="foo/f1" onChange={this.sync} />

      },
      set: function set(ccsync, val, delay, idt) {
        var _sync2;

        __sync((_sync2 = {}, _sync2[ccSyncKey] = ccsync, _sync2.type = 'val', _sync2.val = val, _sync2.delay = delay, _sync2.idt = idt, _sync2));
      },
      // <Input onChange={this.syncInt} /> not work!!!
      // <Input onChange={this.syncInt('foo/bar')} /> ok
      // <input onChange={this.syncInt('foo/bar')} /> ok
      // <input data-ccsync="foo/f1" onChange={this.syncInt('foo/fq')} /> ok
      syncInt: function syncInt(e, delay, idt) {
        var _sync$bind3;

        if (delay === void 0) {
          delay = -1;
        }

        if (idt === void 0) {
          idt = '';
        }

        if (typeof e === 'string') return __sync.bind(null, (_sync$bind3 = {}, _sync$bind3[ccSyncKey] = e, _sync$bind3.type = 'int', _sync$bind3.delay = delay, _sync$bind3.idt = idt, _sync$bind3));

        __sync({
          type: 'int'
        }, e); //<input data-ccsync="foo/f1" onChange={this.syncInt} />

      },
      onUrlChanged: function onUrlChanged(cb) {
        _this.cc.onUrlChanged = cb.bind((0, _assertThisInitialized2["default"])(_this));
      },
      hook: hook,
      emit: function emit(event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        ev.findEventHandlersToPerform.apply(ev, [event, {
          identity: null
        }].concat(args));
      },
      emitIdentity: function emitIdentity(event, identity) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
          args[_key2 - 2] = arguments[_key2];
        }

        ev.findEventHandlersToPerform.apply(ev, [event, {
          identity: identity
        }].concat(args));
      },
      on: function on(event, handler) {
        ev.bindEventHandlerToCcContext(_constant.MODULE_DEFAULT, ccClassKey, ccUniqueKey, event, null, handler);
      },
      onIdentity: function onIdentity(event, identity, handler) {
        ev.bindEventHandlerToCcContext(_constant.MODULE_DEFAULT, ccClassKey, ccUniqueKey, event, identity, handler);
      },
      dispatch: dispatcher.__$$getDispatchHandler(false, ccKey, ccUniqueKey, ccClassKey, _constant.STATE_FOR_ALL_CC_INSTANCES_OF_ONE_MODULE, _constant.MODULE_DEFAULT, null, null, null, -1),
      callDispatch: function callDispatch() {
        var _this$__fragmentParam;

        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        return (_this$__fragmentParam = _this.__fragmentParams.dispatch).bind.apply(_this$__fragmentParam, [(0, _assertThisInitialized2["default"])(_this)].concat(args));
      },
      effect: dispatcher.__$$getEffectHandler(ccKey),
      xeffect: dispatcher.__$$getXEffectHandler(ccKey),
      setModuleState: function setModuleState(module, state, delay, identity) {
        dispatcher.$$changeState(state, {
          ccKey: ccKey,
          module: module,
          stateFor: _constant.STATE_FOR_ALL_CC_INSTANCES_OF_ONE_MODULE,
          broadcastTriggeredBy: null,
          delay: delay,
          identity: identity
        });
      },
      setGlobalState: function setGlobalState(state, delay, identity) {
        dispatcher.$$changeState(state, {
          ccKey: ccKey,
          MODULE_GLOBAL: _constant.MODULE_GLOBAL,
          stateFor: _constant.STATE_FOR_ALL_CC_INSTANCES_OF_ONE_MODULE,
          broadcastTriggeredBy: null,
          delay: delay,
          identity: identity
        });
      },
      state: state,
      props: props,
      outProps: outProps,
      setState: function setState(state, cb) {
        var thisCc = _this.cc;
        var thisState = _this.state;
        var _thisCc$ccState = thisCc.ccState,
            stateModule = _thisCc$ccState.stateModule,
            connect = _thisCc$ccState.connect;
        (0, _computeValueForRef["default"])(stateModule, thisCc.computedSpec, thisCc.refComputed, thisCc.refConnectedComputed, thisState, state, __fragmentParams, true);
        var shouldCurrentRefUpdate = (0, _watchKeyForRef["default"])(stateModule, thisCc.watchSpec, connect, thisState, state);
        if (shouldCurrentRefUpdate) _this.cc.reactSetState(state, cb);
      },
      forceUpdate: function forceUpdate(cb) {
        _this.__fragmentParams.setState(_this.state, cb);
      }
    };
    _this.__fragmentParams = __fragmentParams;
    return _this;
  }

  var _proto = CcFragment.prototype;

  _proto.componentWillMount = function componentWillMount() {
    var _this2 = this;

    var setup = this.props.setup;

    if (setup) {
      var ctx = this.__fragmentParams;
      if (typeof setup !== 'function') throw new Error('type of setup must be function');
      var methodObj = setup(this.__fragmentParams);
      if (!util.isPlainJsonObject(methodObj)) throw new Error('type of setup return result must be an plain json object');
      util.okeys(methodObj).forEach(function (name) {
        var method = methodObj[name];
        if (typeof method === 'function') methodObj[name] = method.bind(_this2, ctx);
      });
      ctx.method = methodObj;
    }

    var thisCc = this.cc;
    var thisState = this.state;
    var _thisCc$ccState2 = thisCc.ccState,
        stateModule = _thisCc$ccState2.stateModule,
        connect = _thisCc$ccState2.connect;
    var computedSpec = thisCc.computedSpec,
        refComputed = thisCc.refComputed,
        refConnectedComputed = thisCc.refConnectedComputed;
    (0, _computeValueForRef["default"])(stateModule, computedSpec, refComputed, refConnectedComputed, thisState, thisState, this.__fragmentParams);
    util.okeys(connect).forEach(function (m) {
      var mState = getState(m);
      (0, _computeValueForRef["default"])(m, computedSpec, refComputed, refConnectedComputed, mState, mState);
    });
  };

  _proto.executeHookEffect = function executeHookEffect(callByDidMount) {
    var _this$__hookMeta = this.__hookMeta,
        effectCbArr = _this$__hookMeta.effectCbArr,
        effectCbReturnArr = _this$__hookMeta.effectCbReturnArr;

    if (callByDidMount) {
      this.__hookMeta.isCcFragmentMounted = true;
      effectCbArr.forEach(function (cb) {
        var cbReturn = cb();

        if (typeof cbReturn === 'function') {
          effectCbReturnArr.push(cbReturn);
        } else {
          effectCbReturnArr.push(null);
        }
      });
    } else {
      var effectSeeResult = this.__hookMeta.effectSeeResult;
      effectCbArr.forEach(function (cb, idx) {
        var shouldEffectExecute = effectSeeResult[idx];

        if (shouldEffectExecute) {
          var cbReturn = cb();

          if (typeof cbReturn === 'function') {
            effectCbReturnArr[idx] = cbReturn;
          }
        }
      });
    }
  };

  _proto.executeSetupEffect = function executeSetupEffect(callByDidMount) {
    var effectItems = this.__staticEffectMeta.effectItems;

    if (callByDidMount) {
      effectItems.forEach(function (item) {
        if (item.immediate === false) return;
        item.fn();
      });
    } else {
      //callByDidUpdate
      var prevState = this.cc.prevState;
      var curState = this.state;
      effectItems.forEach(function (item) {
        var status = item.status,
            stateKeys = item.stateKeys,
            fn = item.fn;
        if (status === _constant.EFFECT_STOPPED) return;

        if (stateKeys) {
          var keysLen = stateKeys.length;
          if (keysLen === 0) return;
          var shouldEffectExecute = false;

          for (var i = 0; i < keysLen; i++) {
            var key = stateKeys[i];
            var targetCurState = void 0,
                targetPrevState = void 0,
                targetKey = void 0;

            if (key.includes('/')) {
              var _key$split = key.split('/'),
                  module = _key$split[0],
                  unmoduledKey = _key$split[1];

              var _prevState = getPrevState(module);

              if (!_prevState) {
                util.justWarning("key[" + key + "] is invalid, its module[" + module + "] has not been declared in store!");
                continue;
              }

              if (!moduleName_stateKeys_[module].includes(unmoduledKey)) {
                util.justWarning("key[" + key + "] is invalid, its unmoduledKey[" + unmoduledKey + "] has not been declared in state!");
                continue;
              }

              targetCurState = getState(module);
              targetPrevState = _prevState;
              targetKey = unmoduledKey;
            } else {
              targetCurState = curState;
              targetPrevState = prevState;
              targetKey = key;
            }

            if (targetPrevState[targetKey] !== targetCurState[targetKey]) {
              shouldEffectExecute = true;
              break;
            }
          }

          if (shouldEffectExecute) {
            fn();
          }
        } else {
          fn();
        }
      });
    }
  };

  _proto.componentDidMount = function componentDidMount() {
    this.executeSetupEffect(true);
    this.executeHookEffect(true);
  };

  _proto.shouldComponentUpdate = function shouldComponentUpdate(_, nextState) {
    var curState = this.state;
    this.cc.prevState = curState;
    return curState !== nextState;
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    this.executeSetupEffect();
    this.executeHookEffect();
    this.cc.prevState = this.state; //!!!  重置prevState，防止其他模块的更新操作再次执行executeSetupEffect时，判断shouldEffectExecute失效
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.__hookMeta.effectCbReturnArr.forEach(function (cb) {
      if (cb) cb();
    });

    var _this$cc$ccState = this.cc.ccState,
        ccUniqueKey = _this$cc$ccState.ccUniqueKey,
        ccClassKey = _this$cc$ccState.ccClassKey;
    ev.offEventHandlersByCcUniqueKey(ccUniqueKey);
    ccRef.unsetRef(ccClassKey, ccUniqueKey);
    if (_Component.prototype.componentWillUnmount) _Component.prototype.componentWillUnmount.call(this);
  };

  _proto.render = function render() {
    var _this$props = this.props,
        children = _this$props.children,
        render = _this$props.render;
    var view = render || children;

    if (typeof view === 'function') {
      this.__fragmentParams.state = this.state; //注意这里，一定要每次都取最新的

      return view(this.__fragmentParams) || _react["default"].createElement(_react.Fragment);
    } else {
      if (_react["default"].isValidElement(view)) {
        util.justWarning("you are trying to specify a react dom to be CcFragment's children, it will never been rendered again no matter how your state changed!!!");
      }

      return view;
    }
  };

  return CcFragment;
}(_react.Component);

exports["default"] = CcFragment;